# encoding=utf-8

"""
Generate training and test images.

"""

__all__ = (
    'generate_ims',
)

import numpy as np
import math
import os
import random
import sys

import cv2
import numpy

from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont

import common
from common import OUTPUT_SHAPE

# fonts = ["fonts/Farrington-7B-Qiqi.ttf", "fonts/Arial.ttf", "fonts/times.ttf"]
fonts = ["fonts/msyh.ttf"]
FONT_HEIGHT = 32  # Pixel size to which the chars are resized


CHARS=common.CHARS[:]
CHARS.append(" ")
CHARS.append("·")
#为每个字符绘制图片
def make_char_ims(output_height, font):
    #32*4
    font_size = output_height * 4
    #加载一个TrueType或者OpenType字体文件，并且创建一个字体对象
    font = ImageFont.truetype(font, font_size)
    #font.getsize(d)，返回给定文本的宽度和高度，返回值为2元组，(width, height)，得到最大的高度
    height = max(font.getsize(d)[1] for d in CHARS)
    for c in CHARS:
        #得到宽度
        width = font.getsize(c)[0]
        #创建一个图片
        im = Image.new("RGBA", (width, height), (0, 0, 0))
        draw = ImageDraw.Draw(im)
        #写入字符
        draw.text((0, 0), c, (255, 255, 255), font=font)
        scale = float(output_height) / height
        im = im.resize((int(width * scale), output_height), Image.ANTIALIAS)
        #im.show()
        yield c, numpy.array(im)[:, :, 0].astype(numpy.float32) / 255.

def make_char_ims_chinese(output_height, font,ch):
    #32*4
    font_size = output_height * 4
    #加载一个TrueType或者OpenType字体文件，并且创建一个字体对象
    font = ImageFont.truetype(font, font_size)
    #font.getsize(d)，返回给定文本的宽度和高度，返回值为2元组，(width, height)，得到最大的高度
    height = max(font.getsize(d)[1] for d in CHARS)
    #得到宽度
    width = font.getsize(ch)[0]
    #创建一个图片
    im = Image.new("RGBA", (width, height), (0, 0, 0))
    draw = ImageDraw.Draw(im)
    #写入字符
    draw.text((0, 0), ch, (255, 255, 255), font=font)
    scale = float(output_height) / height
    im = im.resize((int(width * scale), output_height), Image.ANTIALIAS)
    #im.show()
    return ch, numpy.array(im)[:, :, 1].astype(numpy.float32) / 255.


def get_all_font_char_ims(out_height):
    result = []
    for font in fonts:
        result.append(dict(make_char_ims(out_height, font)))
    return result

#设置旋转矩阵
def euler_to_mat(yaw, pitch, roll):
    # Rotate clockwise about the Y-axis
    c, s = math.cos(yaw), math.sin(yaw)
    M = numpy.matrix([[c, 0., s],
                      [0., 1., 0.],
                      [-s, 0., c]])

    # Rotate clockwise about the X-axis
    c, s = math.cos(pitch), math.sin(pitch)
    M = numpy.matrix([[1., 0., 0.],
                      [0., c, -s],
                      [0., s, c]]) * M

    # Rotate clockwise about the Z-axis
    c, s = math.cos(roll), math.sin(roll)
    M = numpy.matrix([[c, -s, 0.],
                      [s, c, 0.],
                      [0., 0., 1.]]) * M

    return M


def pick_colors():
    first = True
    while first or plate_color - text_color < 0.3:
        text_color = random.random()
        plate_color = random.random()
        if text_color > plate_color:
            text_color, plate_color = plate_color, text_color
        first = False
    return text_color, plate_color


def make_affine_transform(from_shape, to_shape,
                          min_scale, max_scale,
                          scale_variation=1.0,
                          rotation_variation=1.0,
                          translation_variation=1.0):
    out_of_bounds = False

    from_size = numpy.array([[from_shape[1], from_shape[0]]]).T
    to_size = numpy.array([[to_shape[1], to_shape[0]]]).T

    scale = random.uniform((min_scale + max_scale) * 0.5 -
                           (max_scale - min_scale) * 0.5 * scale_variation,
                           (min_scale + max_scale) * 0.5 +
                           (max_scale - min_scale) * 0.5 * scale_variation)
    if scale > max_scale or scale < min_scale:
        out_of_bounds = True
    roll = random.uniform(-0.3, 0.3) * rotation_variation
    pitch = random.uniform(-0.2, 0.2) * rotation_variation
    yaw = random.uniform(-1.2, 1.2) * rotation_variation

    # Compute a bounding box on the skewed input image (`from_shape`).
    m = euler_to_mat(yaw, pitch, roll)
    #print(m)
    M = m[1:3, 1:3]
    #print(M)
    
    h, w = from_shape
    corners = numpy.matrix([[-w, +w, -w, +w],
                            [-h, -h, +h, +h]]) * 0.5
    skewed_size = numpy.array(numpy.max(M * corners, axis=1) -
                              numpy.min(M * corners, axis=1))

    # Set the scale as large as possible such that the skewed and scaled shape
    # is less than or equal to the desired ratio in either dimension.
    scale *= numpy.min(to_size / skewed_size) * 1.1

    # Set the translation such that the skewed and scaled image falls within
    # the output shape's bounds.
    trans = (numpy.random.random((2, 1)) - 0.5) * translation_variation
    trans = ((2.0 * trans) ** 5.0) / 2.0
    if numpy.any(trans < -0.5) or numpy.any(trans > 0.5):
        out_of_bounds = True
    trans = (to_size - skewed_size * scale) * trans

    center_to = to_size / 2.
    center_from = from_size / 2.

    M = euler_to_mat(yaw, pitch, roll)[:2, :2]
    M *= scale
    M = numpy.hstack([M, trans + center_to - M * center_from])
    return M, out_of_bounds


def generate_code():
    f = ""
    #随机选择是否添加空白格子
    append_blank = random.choice([True, False])
    length = random.choice(common.LENGTHS)
    blank = ''
    #添加空格
    if common.ADD_BLANK:
        blank = ' '

    for i in range(length):
        if 0 == i % 4 and append_blank:
            #是否添加空格
            f = f + blank
        #随机选择一个字符
        f = f + random.choice(common.CHARS)
    #返回一个字符
    return f

def generate_code_chinese():
    f = ""
    #随机选择是否添加空白格子
    append_blank = True
    length = random.choice(common.LENGTHS)
    blank = ''
    #添加空格
    if common.ADD_BLANK:
        blank = ' '
    
    f = f + random.choice(list(common.LETTERS))
    f += "·"
    
    for i in range(length-1):
        f = f + random.choice(common.CHARS)
    #返回一个字符
    return f


def rounded_rect(shape, radius):
    out = numpy.ones(shape)
    out[:radius, :radius] = 0.0
    out[-radius:, :radius] = 0.0
    out[:radius, -radius:] = 0.0
    out[-radius:, -radius:] = 0.0

    cv2.circle(out, (radius, radius), radius, 1.0, -1)
    cv2.circle(out, (radius, shape[0] - radius), radius, 1.0, -1)
    cv2.circle(out, (shape[1] - radius, radius), radius, 1.0, -1)
    cv2.circle(out, (shape[1] - radius, shape[0] - radius), radius, 1.0, -1)

    return out

#字体的高度，字体图片集s
def generate_plate(font_height, char_ims):
    #随机填充值
    h_padding = random.uniform(0.2, 0.4) * font_height
    v_padding = random.uniform(0.1, 0.3) * font_height
    #随机字符间隔
    spacing = font_height * random.uniform(-0.01, 0.05)
    radius = 1 + int(font_height * 0.1 * random.random())
    #返回一个字符，有可能包含空格
    code = generate_code()
    #字符的宽度
    text_width = sum(char_ims[c].shape[1] for c in code)
    text_width += (len(code) - 1) * spacing
    #生成图片大小
    out_shape = (int(font_height + v_padding * 2),
                 int(text_width + h_padding * 2))
    #选择一个颜色
    text_color, plate_color = pick_colors()

    text_mask = numpy.zeros(out_shape)

    x = h_padding
    y = v_padding
    for c in code:
        char_im = char_ims[c]
        ix, iy = int(x), int(y)
        text_mask[iy:iy + char_im.shape[0], ix:ix + char_im.shape[1]] = char_im
        x += char_im.shape[1] + spacing

    plate = (numpy.ones(out_shape) * plate_color * (1. - text_mask) + numpy.ones(out_shape) * text_color * text_mask)

    return plate, rounded_rect(out_shape, radius), code.replace(" ", "")

#字体的高度，字体图片集s
def generate_plate_chinese(font_height, char_ims):
    ch_img = make_char_ims_chinese(FONT_HEIGHT,fonts[0],"苏")
    #随机填充值
    h_padding = random.uniform(0.2, 0.4) * font_height
    v_padding = random.uniform(0.1, 0.3) * font_height
    #随机字符间隔
    spacing = font_height * random.uniform(-0.01, 0.05)
    radius = 1 + int(font_height * 0.1 * random.random())
    #返回一个字符，有可能包含空格
    code = generate_code_chinese()
    #字符的宽度
    text_width = ch_img[1].shape[1]
    text_width += sum(char_ims[c].shape[1] for c in code)
    text_width += len(code) * spacing
    #生成图片大小
    out_shape = (int(font_height + v_padding * 2),
                 int(text_width + h_padding * 2))
    #选择一个颜色
    text_color, plate_color = pick_colors()

    text_mask = numpy.zeros(out_shape)

    x = h_padding
    y = v_padding
    
    char_im = ch_img[1]
    ix, iy = int(x), int(y)
    text_mask[iy:iy + char_im.shape[0], ix:ix + char_im.shape[1]] = char_im
    x += char_im.shape[1] + spacing
    
    for c in code:
        char_im = char_ims[c]
        ix, iy = int(x), int(y)
        text_mask[iy:iy + char_im.shape[0], ix:ix + char_im.shape[1]] = char_im
        x += char_im.shape[1] + spacing

    plate = (numpy.ones(out_shape) * plate_color * (1. - text_mask) + numpy.ones(out_shape) * text_color * text_mask)

    return plate, rounded_rect(out_shape, radius), code.replace(" ", "")


def generate_bg(num_bg_images):
    found = False
    while not found:
        #fname = "bgs/{:08d}.jpg".format(random.randint(0, num_bg_images - 1))
        fname = "bgs/12345678.jpg"
        #读取背景图片，转化为float型
        bg = cv2.imread(fname, cv2.IMREAD_GRAYSCALE) / 255.
        #OUTPUT_SHAPE=>(64,256),判断背景图片的大小
        if (bg.shape[1] >= OUTPUT_SHAPE[1] and
                    bg.shape[0] >= OUTPUT_SHAPE[0]):
            found = True
    #对背景图片随机的裁剪
    x = random.randint(0, bg.shape[1] - OUTPUT_SHAPE[1])
    y = random.randint(0, bg.shape[0] - OUTPUT_SHAPE[0])
    bg = bg[y:y + OUTPUT_SHAPE[0], x:x + OUTPUT_SHAPE[1]]
    #返回背景图片
    return bg

#得到单个字符的图片s和背景色图片s
def generate_im(char_ims, num_bg_images):
    #得到背景图片
    bg = generate_bg(num_bg_images)

    #plate, plate_mask, code = generate_plate(FONT_HEIGHT, char_ims)
    plate, plate_mask, code = generate_plate_chinese(FONT_HEIGHT, char_ims)

    M, out_of_bounds = make_affine_transform(
        from_shape=plate.shape,
        to_shape=bg.shape,
        min_scale=0.8,
        max_scale=0.9,
        rotation_variation=0.3,
        scale_variation=1.0,
        translation_variation=1.0)
    #print(M)
    plate = cv2.warpAffine(plate, M, (bg.shape[1], bg.shape[0])) 
    plate_mask = cv2.warpAffine(plate_mask, M, (bg.shape[1], bg.shape[0]))
    
    #pts1 = np.float32([[50,50],[200,50],[50,200]])
    #pts2 = np.float32([[10,10],[200,50],[100,250]])
    #afM = cv2.getAffineTransform(pts1,pts2)
    #print(afM)
    #plate = cv2.warpAffine(plate,afM,(bg.shape[1], bg.shape[0]))
    #plate_mask = cv2.warpAffine(plate_mask,afM,(bg.shape[1], bg.shape[0]))

    out = plate * plate_mask + bg * (1 - plate_mask)
    out = cv2.resize(out, (OUTPUT_SHAPE[1], OUTPUT_SHAPE[0]))

    out += numpy.random.normal(scale=0.05, size=out.shape)
    out = numpy.clip(out, 0., 1.)
    return out, code, not out_of_bounds

#生成图片
def generate_ims(num_images):
    """
    Generate a number of number plate images.

    :param num_images:
        Number of images to generate.

    :return:
        Iterable of number plate images.

    """
    variation = 1.0
    char_ims = get_all_font_char_ims(FONT_HEIGHT)
    #make_char_ims_chinese(FONT_HEIGHT,fonts[0],"苏")
    num_bg_images = len(os.listdir("bgs"))
    for i in range(num_images):
        yield generate_im(random.choice(char_ims), num_bg_images)


if __name__ == "__main__":
    make_char_ims_chinese(FONT_HEIGHT,fonts[0],"苏")
    im_gen = generate_ims(1)
    for img_idx, (im, c, p) in enumerate(im_gen):
        cv2.imshow("苏"+c,im)
        cv2.waitKey(10000)
